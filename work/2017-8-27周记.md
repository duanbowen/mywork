
### 这里是2017-08-16 ~ 2017-08-27 之间的笔记

- static-server / http-server 的使用  
用于将你的本地代码搭建在一个本地服务器上，
npm install http-server -g 全局安装，然后在当前目录下执行 http-server -i {指定路径 or 不指定}
- artTemplate 的多层循环 
这里有一个坑就是 arttemplate的第一层默认值为 $data , 以后的默认值为 value , 并且这些默认值都是相对整个页面，即是说他们是全局变量，用户名不能重复。
<pre>
{{each orders}}
    {{each $value.list val key}}
           内容输出 {{val.name}}
    {{/each}}
  {{/each}}
</pre>
或者 使用 include 包含另一个
<pre>
{{each orders}}
    {{include 'anotherId' $value.list}}
  {{/each}}


</pre>
``` 
<script id="anotherId" type="text/template7">
  {{each orders}}
    {{each $value.list val key}}
           内容输出 {{val.name}}
    {{/each}}
  {{/each}}
</script> 
```  
- 跨域问题  
    原因 : 因为javascript 的同源策略限制(域名相同，协议相同，端口号相同)，
    www.a.com域名下的js无法操作www.b.com/test.a.com/a.com:1010 域名下的对象，不同域名之间不能相互访问。
    解决方式  
    - 使用script，style,img,iframe等标签元素的src元素的跨域访问性质,将接口地址放在 script标签的url中 外加一个callback参数
    或者直接使用 jquery封装好的 
    ```
     $.ajax({
         crossDomain: true,//如果不设置这个即使写的是post请求也会自动变成get
          type : 'GET',
          dataType : 'jsonp',
          data : {
            city : city,
            appkey : '21f4782df8c57e19'
          },
          url : "http://api.jisuapi.com/weather/query",
          success : function (data){
            console.log(data);
          }
    });
    ``` 
    - 目前 所有浏览器在执行ajax的时候都会去检查ajax的请求是**简单请求还是非简单请求**
      - 简单请求 
      浏览器会在这次的ajax请求头header加上 Origin字段 , 用于说明此次请求来自哪个源(协议 + 域名 + 端口),然后服务器根据这个值，判定是否同意此次请求。  
      如果 origin指定的源不在许可范围内,服务器还是会返回一个正常的http回应包，浏览器发现返回的包没有包含 **access-control-allow-origin** 这个字段,就会抛出一个异常并被 XMLHttpRequest的onerror回调函数捕获，在这个过程中，服务端返回 状态码可能是 200.
      - 非简单请求  PUT /DELETE  application/json  
      第一次预检 ：浏览器会首先向服务端发送一询问http包，里面头部包含  
      Origin ： 请求源地址
      Access-Control-Request-Method ： ajax客户端请求的方式
      Access-Control-Request-Headers : 请求的头部信息
      服务端返回 
      Access-Control-Allow-Origin : * //表示同意任何跨源请求
      如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是XMLHttpRequest 对象会抛出异常信息 : Origin (源地址) is not allowed by Access-Control-Allow-Origin.  
      一但通过了 预检 ,浏览器就会发送正常的信息到服务端。(跟简单请求一样 加上origin头部)


 
- 封装ajax  
这里因为涉及到多层次，所以我还是使用的promise。
```
	var mypromise = new Promise(function (resolve, reject) {
				$.ajax({
					"type": "POST",
					"url": url,
					"headers": header,
					"dataType": 'JSONP',
					"data": JSON.stringify(data),
					success: function (result) {
						console.log(result);
						resolve(result);

					},
					error: function (xhr, type) {
						reject(xhr);
					}
				})
		});
	return mypromise;
```
- cookie 使用  
  - domain cookie 所在的域 ，默认为请求的网址。(不同域之间共享cookie )  
  域名a : a.test.com  
  域名b : b.test.com  
  b访问a中cookie 需要将domain 设置为 test.com  cookie访问可以跨二级域名 但是不能跨一级域名  
  如何 a域名设置一个 cookie 的domain为 b.exam.com,那么a域名下不能访问这个cookie,而b域名下可以。
  - path 同域不同目录cookie访问规则
  现在都在 a 域名下 ，如果此时 在 /pages/index.html目录下设置一个cookie1 ,那么/pages/menu/ 目录下不能访问 cookie1,而/pages/menu/ 下的 cokie2 可以在/pages/index.html中访问.  

  - cookie 的path domain不一样 就会产生相同key的cookie

- 表单  
  在表单中 ，点击任意button 会自动提交表单,所以如何限制button的表单提交事件
  ` <button type="button" > </button> `  
  详见css文件夹中 form.html   
  input标签 验证码限制  
  ``` 
   <input type="number" class="weui-input" 
                onkeyup="this.value=this.value.replace(/\D/g,'')" //  /\d+/g 匹配多个数字 
                onafterpaste="this.value=this.value.replace(/\D/g,'')" //复制粘贴 替换中文
                required pattern="[0-9]{4}" 
                oninput="if(value.length > 4){value = value.slice(0,4)}"
                placeholder="{{verification_code}}" 
                emptyTips="{{empty_verification_code}}" 
                notMatchTips="{{notMatch_verification_code}}"
                     />   
                     